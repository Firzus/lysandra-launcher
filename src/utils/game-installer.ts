import { invoke } from '@tauri-apps/api/core'
import { join } from '@tauri-apps/api/path'

import i18n from './i18n'
import { getGamePaths, GAME_IDS } from './paths'
import { downloadOperation, fetchManifest } from './update-service'
import { checkFileHash } from './hash-verification'
import { extractZipAsync, ExtractionProgressEvent } from './zip'
import { getGameRepository } from './game-data'
import {
  initializeGameDirectoryStructure,
  checkGameDirectoryStructure,
} from './game-directory-manager'

export type GameInstallProgress = {
  step:
    | 'fetching'
    | 'downloading'
    | 'verifying'
    | 'extracting'
    | 'installing'
    | 'cleaning'
    | 'complete'
  progress?: number
  message: string
}

export type GameInstallResult = {
  success: boolean
  version?: string
  error?: string
}

/**
 * T√©l√©charge et installe un jeu dans la nouvelle architecture
 * G√®re tout le processus : t√©l√©chargement ‚Üí v√©rification ‚Üí extraction ‚Üí nettoyage
 */
export async function downloadAndInstallGame(
  gameId: string,
  owner: string,
  repo: string,
  onProgress?: (progress: GameInstallProgress) => void,
): Promise<GameInstallResult> {
  try {
    console.log(`üéÆ Starting installation of ${gameId} from ${owner}/${repo}`)

    // 0. Initialiser la structure des dossiers AVANT tout
    console.log(`üìÅ Initializing game directory structure...`)
    onProgress?.({ step: 'fetching', message: i18n.t('game.install.initializing_structure') })
    const initResult = await initializeGameDirectoryStructure(gameId)
    if (!initResult.success) {
      throw new Error(`Failed to initialize directory structure: ${initResult.errors.join(', ')}`)
    }

    const gamePaths = await getGamePaths(gameId)
    console.log(`üìÅ Game paths:`, gamePaths)

    // 1. R√©cup√©rer le manifeste
    console.log(`üìã Fetching manifest...`)
    onProgress?.({ step: 'fetching', message: i18n.t('game.install.fetching') })
    const manifest = await fetchManifest(owner, repo)
    const { version, url, hash } = manifest
    console.log(`‚úÖ Manifest fetched: version=${version}, url=${url}`)

    // 2. Pr√©parer les chemins
    console.log(`üìÇ Preparing paths...`)
    const cacheDir = await join(await gamePaths.root, '..', '..', 'cache') // Dossier cache du launcher
    const zipFileName = `${gameId}-${version}.zip`
    const zipFilePath = await join(cacheDir, zipFileName)
    console.log(`üì¶ Cache dir: ${cacheDir}`)
    console.log(`üì¶ Zip file path: ${zipFilePath}`)

    // S'assurer que le dossier cache existe
    console.log(`üìÅ Creating cache directory...`)
    await invoke('create_dir_all', { path: cacheDir })

    // 3. T√©l√©charger le jeu
    console.log(`‚¨áÔ∏è Starting download...`)
    onProgress?.({
      step: 'downloading',
      message: i18n.t('game.install.downloading', { game: gameId, version }),
    })
    await downloadOperation(version, url, cacheDir, zipFileName)
    console.log(`‚úÖ Download completed`)

    // 4. V√©rifier l'int√©grit√©
    console.log(`üîç Verifying file integrity...`)
    onProgress?.({ step: 'verifying', message: i18n.t('game.install.verifying') })
    if (!(await checkFileHash(zipFilePath, hash))) {
      throw new Error("La v√©rification d'int√©grit√© a √©chou√©")
    }
    console.log(`‚úÖ File integrity verified`)

    // 5. Extraire dans le dossier d'installation
    console.log(`üì¶ Extracting to: ${gamePaths.install}`)
    onProgress?.({ step: 'extracting', message: i18n.t('game.install.extracting') })

    // S'assurer que le dossier d'installation existe (double v√©rification)
    await invoke('create_dir_all', { path: gamePaths.install })

    // Extraction asynchrone avec progression
    await extractZipAsync(zipFilePath, gamePaths.install, (progress: ExtractionProgressEvent) => {
      console.log(`üìÑ Extracting: ${progress.current_file_name} (${progress.progress_percentage}%)`)
      onProgress?.({
        step: 'extracting',
        progress: progress.progress_percentage,
        message: i18n.t('game.install.extracting_file', {
          file: progress.current_file_name,
          current: progress.current_file,
          total: progress.total_files,
        }),
      })
    })
    console.log(`‚úÖ Extraction completed`)

    // 6. Sauvegarder la version
    console.log(`üíæ Saving version file...`)
    onProgress?.({ step: 'installing', message: i18n.t('game.install.installing') })
    await invoke('write_text_file', {
      path: gamePaths.versionFile,
      content: version,
    })
    console.log(`‚úÖ Version file saved: ${version}`)

    // 7. V√©rifier la structure finale
    console.log(`üîç Verifying final directory structure...`)
    const finalCheck = await checkGameDirectoryStructure(gameId)
    if (!finalCheck.isValid) {
      console.warn(`‚ö†Ô∏è Directory structure verification failed:`, finalCheck.missingDirectories)
      // Tenter de corriger les probl√®mes
      const repairResult = await initializeGameDirectoryStructure(gameId)
      if (!repairResult.success) {
        console.warn(`‚ö†Ô∏è Failed to repair directory structure: ${repairResult.errors.join(', ')}`)
      }
    }

    // 8. Nettoyer le fichier ZIP
    console.log(`üßπ Cleaning up...`)
    onProgress?.({ step: 'cleaning', message: i18n.t('game.install.cleaning') })
    try {
      await invoke('delete_file', { path: zipFilePath })
      console.log(`‚úÖ Cleanup completed`)
    } catch (cleanupError) {
      console.warn(`‚ö†Ô∏è Cleanup failed (non-critical):`, cleanupError)
    }

    // 9. Termin√©
    console.log(`üéâ Installation completed successfully!`)
    onProgress?.({
      step: 'complete',
      message: i18n.t('game.install.complete', { game: gameId, version }),
    })

    return {
      success: true,
      version,
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Erreur inconnue'
    const errorStack = error instanceof Error ? error.stack : 'No stack trace'

    console.error('‚ùå Game installation failed:', errorMessage)
    console.error('üìç Error details:', error)
    console.error('üìö Stack trace:', errorStack)

    return {
      success: false,
      error: errorMessage,
    }
  }
}

/**
 * Met √† jour un jeu existant
 * M√™me processus que l'installation mais avec gestion de l'ancienne version
 */
export async function updateGame(
  gameId: string,
  owner: string,
  repo: string,
  onProgress?: (progress: GameInstallProgress) => void,
): Promise<GameInstallResult> {
  try {
    const gamePaths = await getGamePaths(gameId)

    // Sauvegarder l'ancienne version pour rollback si n√©cessaire
    let oldVersion = ''

    try {
      oldVersion = await invoke<string>('read_text_file', { path: gamePaths.versionFile })
    } catch {
      // Pas d'ancienne version
    }

    onProgress?.({ step: 'fetching', message: i18n.t('game.install.update_preparing') })

    // Utiliser la m√™me logique que l'installation
    const result = await downloadAndInstallGame(gameId, owner, repo, onProgress)

    if (result.success && oldVersion) {
      console.log(`‚úÖ Game updated from ${oldVersion} to ${result.version}`)
    }

    return result
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Erreur de mise √† jour'

    console.error('Game update failed:', errorMessage)

    return {
      success: false,
      error: errorMessage,
    }
  }
}

/**
 * Fonction helper pour installer Lysandra sp√©cifiquement
 */
export async function installLysandra(
  onProgress?: (progress: GameInstallProgress) => void,
): Promise<GameInstallResult> {
  const { owner, repo } = getGameRepository(GAME_IDS.LYSANDRA)

  return await downloadAndInstallGame(GAME_IDS.LYSANDRA, owner, repo, onProgress)
}

/**
 * Fonction helper pour mettre √† jour Lysandra sp√©cifiquement
 */
export async function updateLysandra(
  onProgress?: (progress: GameInstallProgress) => void,
): Promise<GameInstallResult> {
  const { owner, repo } = getGameRepository(GAME_IDS.LYSANDRA)

  return await updateGame(GAME_IDS.LYSANDRA, owner, repo, onProgress)
}
